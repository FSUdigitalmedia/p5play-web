<!DOCTYPE html>
<html lang="ja" class="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>p5play : World</title>
	<link rel="icon" href="/assets/p5play_logo.svg">
	<link rel="stylesheet" href="/learn/style.css">
</head>

<body class="dark">
	<article style="display: none;">
		<nav id="topNav">
			<a href="index.html" id="logoLink" class="active">
				<img alt="p5play logo" src="/assets/p5play_logo.svg" class="p5play_logo">
				<span>p5play</span>
			</a>
			<hr>
			<a href="canvas.html">Canvas</a>
			<a href="sound.html">Sound</a>
			<a href="tiles.html">Tiles</a>
			<a href="world.html" class="active">World</a>
			<hr>
			<a id="darkMode" onclick="toggleDarkMode()" tabindex="0" role="button" title="dark mode toggle">
				<div id="darkModeIcon"></div>
			</a>
		</nav>
		<div class="break"></div>

		<div id="page-0" class="page">
			<div class="minis horiz">
				<md id="md0-0">
					<h2 id="ワールド">ワールド</h2>
					<p>p5play の各インスタンスには、物理シミュレーションを制御するために使用できる独自の <code>world</code> オブジェクトがあります。</p>
					<p>このオブジェクトの最も重要なプロパティは <code>gravity</code> で、x 成分と y 成分を持っています。</p>
				</md>
				<md id="md0-1">
					<h2 id="スリープ">スリープ</h2>
					<p><code>world.allowSleeping</code> はデフォルトで true です。</p>
					<p>スプライトは、動きを止めて新たに何も衝突しないときに "sleeping" 状態になります。 "Sleeping" スプライトは物理シミュレーション中に無視されるため、通常は Box2D
						物理エンジンソルバが不必要な計算を行う必要がなくなります。これはパフォーマンスには良いですが、場合によっては問題を引き起こすこともあります。</p>
					<p>スプライトを起こすには <code>sprite.sleeping</code> を false に設定します。また、 <code>sprite.allowSleeping</code> を
						false に設定することで、スプライトごとにスリープを無効にすることもできます。</p>
				</md>
			</div>
			<div class="minis horiz">
				<script type="mie/p5" id="sleeping" horiz="">
let ball, floor;

function setup() {
	new Canvas(80, 240);
	world.gravity.y = 10;
	ball = new Sprite(40, 30, 50);
	floor = new Sprite(40, 155, 80, 5, 's');
}

function draw() {
	clear();
	if (frameCount == 100)	floor.rotation = 10;
}
				</script>
				<script type="mie/p5" id="wake-up!" horiz="">
let ball, floor;

function setup() {
	new Canvas(80, 256);
	world.gravity.y = 10;
	ball = new Sprite(40, 30, 50);
	floor = new Sprite(40, 155, 80, 5, 's');
}

function draw() {
	clear();
	if (frameCount == 100)	{
		ball.sleeping = false;
		floor.rotation = 10;
	}
}
				</script>
			</div>
		</div>
		<div id="page-1" class="page">
			<div class="minis horiz">
				<md id="md1-0">
					<h2 id="時間のコントロール">時間のコントロール</h2>
					<p>デフォルトでは、p5.js の draw 関数が実行された後、p5play は以下の 3 つの関数をこの順番で呼び出します：</p>
					<ul>
						<li><code>allSprites.draw()</code> : すべてのスプライトを描画します</li>
						<li><code>world.step()</code> : 物理シミュレーションを進行させます</li>
						<li><code>allSprites.update()</code> : アニメーションとマウスイベントを更新します</li>
					</ul>
					<p>しかし、これらのプロセスを自分で呼び出すことによって、手動で制御することもできます。</p>
				</md>
				<md id="md1-1">
					<h2 id="worldstep">world.step</h2>
					<p><code>world.step</code>関数は、物理シミュレーションを 1/60 秒進めた後の、すべてのスプライトの位置と速度を計算します。</p>
					<p><code>world.autoStep =
							false</code>を設定すると自動ステップが無効になり、時間が一時停止します！その後、物理シミュレーションを進めたいときに<code>world.step</code>を手動で呼び出すことができます。すべてのスプライトが描画された後にのみ実行してください。
					</p>
					<p>このミニ例では、タイムステップを入力パラメータとして提供する方法が示されていますが、Box2D 物理エンジンソルバーは 1/30
						秒のタイムステップまでしか安定していません。より長い時間でシミュレーションを進めたい場合は、<code>world.step</code>を複数回呼び出してください。</p>
				</md>
			</div>
			<script type="mie/p5" id="world.step">
let ball, box;
		
function setup() {
	new Canvas(500, 192);

	ball = new Sprite(250, 100, 20);
	ball.speed = 10;
	ball.direction = 45;
	ball.bounciness = 1;
	ball.friction = 0;
	ball.strokeWeight = 0;

	box = new Sprite(250, 96, 490, 180, 's');
	box.shape = 'chain';
}

function draw() {
	if (mouse.pressing()) {
		background(0, 0, 0, 30);
		allSprites.draw();
		world.step(1/240);
	} else {
		background(0);
	}
}
			</script>
		</div>
		<div id="page-2" class="page">
			<md id="md2-0">
				<h2 id="パフォーマンステスト">パフォーマンステスト</h2>
				<p><code>renderStats</code> 関数は、描画されたスプライトの数、現在の FPS の近似値、前の 1 秒間に達成した平均、最小、最大 FPS を表示します。</p>
				<p>このコンテキストでの FPS は、コンピュータが 1
					秒間に生成できるフレーム数を指します。これにはフレームを生成するために必要な物理計算や、フレームが実際に画面に表示されるまでの遅延は含まれません。FPS
					が高いほど、ゲームのパフォーマンスが向上します。</p>
				<p>この関数は、おおよそのパフォーマンステストに使用できます。より正確な結果を得るには、ウェブブラウザのパフォーマンステストツールを使用してください。</p>
				<p>一般的に、スプライトの数を少なくし、小さなキャンバスを使用すると、ゲームのパフォーマンスが向上します。パフォーマンスを向上させるために、p5.js の <code>clear</code>
					関数を使用しないか、キャンバスのピクセルの色をサンプリングすることは避けてください。</p>
			</md>
			<script type="mie/p5" id="renderStats">
function setup() {
	new Canvas(500, 250);

	for (let i = 0; i < 25; i++) {
		let x = 430 - i * 20;
		for (let j = 0; j < 12; j++) {
			new Sprite(x + j * 10, 5 + i * 10, 9, 9);
		}
	}
}

function draw() {
	background(20);
	if (mouse.presses()) new Sprite(mouse.x, mouse.y, 25);
	if (mouse.pressing()) {
		allSprites.at(-1).moveTowards(mouse);
	}
	renderStats();
	allSprites.draw();

	// (timeStep, velocityIterations, positionIterations)
	world.step(1 / 60, 8, 3);
}
			</script>
		</div>

		<div class="break"></div>
		<div id="toc">
			<a id="prevPage" class="navLink">前へ</a>
			<div id="pageNav" class="submenu">
				<a data-page="0" href="world.html?page=0">スリープ</a>
				<a data-page="1" href="world.html?page=1">Time のコントロール</a>
				<a data-page="2" href="world.html?page=2">パフォーマンスのチューニング</a>
			</div>
			<a id="nextPage" class="navLink">次へ</a>
		</div>
		<div class="break"></div>
		<footer id="credits" class="text-small">制作・著作: クイントン・アシュリー（@quinton-ashley） ©2022-2024</footer>
	</article>

	<script src="/v3/q5.min.js"></script>
<script src="/v3/planck.min.js"></script>
<script src="/v3/p5play.min.js"></script>
<script>
window.mie = { autoLoad: false };

	</script>
	<script src="/learn/mie.js"></script>
<script src="/learn/learn.js"></script>
</body>

</html>
