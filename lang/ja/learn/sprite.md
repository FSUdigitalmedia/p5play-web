# 0-0

## セットアップと描画

[p5.js](https://p5js.org) (または [q5.js](https://github.com/quinton-ashley/q5.js)) の `setup` 関数内のコードは、プログラムの開始時に実行されます。`new Canvas()` コンストラクタは、スクリーン内にプログラムが描画できる領域を作成します。

p5.js の `draw` 関数は、デフォルトでは 1 秒間に 60 回実行されます。`background` 関数は、キャンバスが描画されるたびに、それを指定した色で塗りつぶすために使用します。

コードサンプルで、キャンバスの幅と高さ（`Canvas` コンストラクタ内の数字）を変更して、プログラムを再実行してみましょう！

# 0-1

## スプライトって何？

スプライトとは、妖精という意味の言葉です！

ビデオゲームの開発者は、キャラクターやアイテムなどの、背景の上で動くものを指して「スプライト」という言葉を使います。

`new Sprite()` コンストラクタで、スプライトのオブジェクトを生成します。これにはスプライトの位置、サイズ、および外観を定義するプロパティが含まれます。

下のコードサンプルで、長方形と円のスプライトのプロパティを編集してみてください！

# 0-2

## やってみよう！

次のコードサンプルで、 `ball` と名付けられたスプライトを、を直径 30 の青い円に変えて、キャンバスの右上の角に配置してみてください。

# 1-0

## スプライトの物理挙動

スプライトのコライダー（衝突を判定する仕組み）は、
他のスプライトとのコリジョン（衝突）を検出するために使用されます。
デフォルトでスプライトが持っているのは `'dynamic'` コライダーで、
これによりスプライトは自由に移動し、重力の影響を受けるようになっています。

`'static'` コライダーを持つスプライトは、動かせません。
`'kinematic'` コライダーを持つスプライトは、プログラム的に移動させることができますが、他のスプライトの影響を受けません。また、他の kinematic コライダーともコリジョンを起こしません。
スプライトのコライダーを `'none'` に設定すると、コライダーを持っていないことになります。

コライダーのタイプは、 `'d'` 、 `'s'` 、 `'k'` および `'n'` のように、それぞれのタイプ名の頭文字で指定することもできます。

コードサンプルを再生するには、右上のリロードアイコンをクリックしてください！

# 1-1

## やってみよう！

`peg` という名前で、static コライダーを持つ円形のスプライトを作成します。次に `block` という名前で、 dynamic コライダーを持つ四角のスプライトを作成します。 peg にぶつかって右側に落っこちるように、 block を配置してみてください。

p5.js の `draw` 関数の実行が終えるたびに、スプライトは自動的に描画され更新されます。 `world` は p5play がロードされるときに生成されますが、デフォルトでは重力は設定されません。 `world.gravity.y` を正の数に設定してみましょう。

さらに腕試ししたい方は、ブロックが落ちた後に元の位置に戻すようにしてみてください。

# 2-0

## 画像付きスプライト

`sprite.image` または `sprite.img` に、p5.Image 画像オブジェクトそのもの、または画像ファイルへの URL パスを設定することで、スプライトに指定した画像を割り当てることができます。

画像の読み込みが完了してからプログラムを開始したい、という場合は、 p5.js 内の `preload` 関数で [`loadImage`](https://p5js.org/reference/#/p5/loadImage) を使用するのがベストです。

`sprite.scale` は、スプライトのコライダーと画像の、両方のサイズを変更します。スケール値に 2 を与えると、スプライトのサイズは２倍になります。

コードサンプルの画像の上で、マウスの左ボタンを押してみてください。 `sprite.debug` プロパティが true に設定されると、スプライトのコライダー部分が見えるようになります。これで分かる通り、コライダーの大きさと画像の大きさは、別々に設定可能なのです！

# 2-1

## ピクセルアート

`spriteArt` 関数で、スプライト用のピクセルアート画像を作成できます。この関数は文字列を引数として受け取り、画像を返します。文字列内の各文字は、画像内のピクセルの色を表現しています。

`spriteArt` 関数の第２引数は、画像のスケール値です。

# 2-2

## やってみよう！

コードサンプルで、あなたオリジナルのピクセルアートを作ってみましょう！　下のアルファベットを参考に、デフォルト時にそれぞれの文字が対応する色を確認してください。

# 2-3

## カスタムカラー

さらに、「カラーパレット」を作成して、`spriteArt` 関数への第３引数に渡すことで、カスタムカラーを使ったピクセルアートを作成することもできます。

p5play のカラーパレットは[JavaScript オブジェクト](https://p5js.org/reference/#/p5/object)形式でなければなりません。シンプルな JS オブジェクトとは、見出しと値のペアの集まりです。ピクセルアートで使用するそれぞれの文字に対し、任意の色を定義することができます。色を作成するには、p5.js の[`color`](https://p5js.org/reference/#/p5/color)関数に、 RGB（赤、緑、青）値、または HEX カラーコードを引数として渡します。

色の指定値を調べるには、[カラーピッカー](https://www.google.com/search?q=google+color+picker)を使うのがいちばんお手軽です。

# 3-0

## スプライトの移動

スプライトを移動させようとして、座標（x, y）を直接編集すると、即座に指定した座標へと「テレポート」します。移動の途中経過の座標を示すことはありません。

このコードサンプルをクリックしてみてください。

# 3-1

スプライトの移動中に、他のスプライトと物理的に干渉させたい場合は、「テレポート」を行ってはいけません！

悪い例がこれです。 p5.js の描画関数によるフレーム毎のレンダリングを利用して、移動をスプライトの「テレポート」で表現すると、どうなるのを示しています。

# 3-2

このページの、以降すべての説明は、移動の方法としてスプライトの x 軸と y 軸の移動量 `velocity` （ベロシティ）、別名 `vel` を変更することによって行っています。

`vel`は p5.js の Vector オブジェクトですが、任意のベクトル関数を使用可能です。

このコードサンプルを再実行して、プレイヤーのスプライトがブロックにぶつかる様子を御覧ください！

# 3-3

場合によっては、スプライトの移動には、 `direction` （方向）と `speed` （速度）を設定するほうが便利かもしれません。

方向は、角度を指定するか、 'up', 'down', 'left', 'right', 'upLeft', 'upRight', 'downLeft', 'downRight' といった方向名を使って設定できます。

# 3-4

`move` 関数は、スプライトの移動を、「現在の位置からの距離」で指定します。方向と速度は、関数の引数として指定することも、前の例のように別々に設定することもできます。

# 3-5

`moveTowards` 関数は、スプライトを特定の位置に向けて、現在の位置との距離とのパーセントぶん移動させます。

このコードサンプルでは、プレイヤーは p5.js の draw 呼び出し毎に、マウスまでの距離の 10％ぶん移動します。そのスピードと、ブロックを弾き飛ばす力は、移動した距離に比例します。

# 3-6

`moveTo` 関数はスプライトを、一定の速度で特定の位置に移動させる「推進力」（インパルス）を発生させることで、移動させます。

しかし、移動中にそのスプライトが、重力などの外力の影響を受けたり、他のスプライトにぶつかるなどすると、その影響によって指定した位置に到達しない可能性があることに注意してください。

「x と y をプロパティとして持つオブジェクト」を引数にするすべての移動関数は、(x, y)の座標数値を使用して呼び出すこともできます。

# 3-7

このページで示した例が、 p5play で利用可能なスプライト移動オプションの一部を理解する助けになれば幸いです！

ただし、 `move` 、 `moveTo` 、および `moveTowards` 関数は、スプライトの現在の動きを強制的に上書きし、新たな方向に動かす、ということには気をつけてください。このことは、必ずしも望ましい結果を生むとは限りません！　重力など、外力を考慮に入れたスプライト移動の方法を学ぶには、「高度な移動」を参照してください。

# 4-0

## スプライトの生成を高速化

Sprite コンストラクタ `new Sprite()` で、スプライトの位置、サイズ、コライダーのタイプを指定できます。

先述のスプライト参照ページで見たように、スプライトを作成するために Sprite コンストラクタに何も入力を追加する必要はありません。しかし、コンストラクタでスプライトのサイズを設定したい場合は、最初にその位置を指定する必要があります。

デフォルトでは、Sprite コンストラクタに入力が与えられない場合、新しいスプライトはキャンバスの中央に位置し、幅と高さが 50 ピクセル、動的な衝突判定器が付いています。

# 4-1

## やってみよう！

スプライトコンストラクタを使用して 2 つのスプライトを作成してみてください。

# 5-0

## コリジョン

スプライトが別のスプライトと衝突する最初のフレームでは、`collides` 関数が true を返します。

スプライトが別のスプライトと衝突している間、`colliding` 関数は衝突が発生しているフレーム数を返します。

2 つのスプライトが衝突した後の最初のフレームでは、`collided` 関数が true を返します。

# 6-0

## オーバーラップ

スプライトはデフォルトで衝突しますが、重なることもできます！

# 6-1

## レイヤー

デフォルトでは、スプライトは作成された順番に描画されます。描画の順序を変更するには、スプライトの `.layer` プロパティを編集します。レイヤー値が最も高いスプライトが最初に描画されます。

# 6-2

スプライトが別のスプライトと重なる最初のフレームでは、`overlaps` 関数が true を返します。

スプライトが別のスプライトと重なっている間、`overlapping` 関数は重なりが発生しているフレーム数を返します。

2 つのスプライトが重なった後の最初のフレームでは、`overlapped` 関数が true を返します。

スプライトがテレポートされたり、その位置が直接変更されたりした場合、スプライト間の物理的な相互作用、衝突や重なりを適切に検出することはできません！

# 6-3

## やってみよう！

青いスプライトが赤いスプライトと重なっている場合に限り、赤に変わるようにしてみてください。

# 6-4

## overlaps と collides を切り替える

デフォルトでは、2 つのスプライト間の重なりをチェックすると、それらはもはや衝突しません。スプライト間の衝突をチェックすることで、これを上書きすることができます。

この例では、スペースキーを押すと、プレイヤーは一時的に壁をすり抜けることができます。

# 7-0

## 角度

スプライトの `rotation` プロパティを直接変更すると、指定された回転角度にテレポートします。

スプライトが回転している間に他のスプライトと物理的に相互作用することを望むなら、スプライトをテレポートさせないでください！

# 7-1

このページの他のすべての回転方法は、スプライトの `rotationSpeed` を変更することによって動作します。

# 7-2

`rotate` 関数を使用して、スプライトを指定した量だけ回転させます。

オプションの 2 つ目のパラメータは、スプライトがフレームごとに回転する速度です。

# 7-3

`rotateTo` 関数を使用して、スプライトを角度に回転させるか、位置に向かせます。`rotateMinTo` 関数は、必要に応じてスプライトの回転速度の符号を変更し、スプライトが目的の角度に向かうための最小角度を回転させます。オプションの第三パラメーターである "facing" 角度は、スプライトがターゲットの位置を向いたときにあるべき角度です。

コード例で facing 角度を 0 から 90 に変更してみてください。その後、クリックすると、スプライトの長い側がマウスを向くように回転します。

# 7-4

`rotateTowards` 関数を使用して、スプライトを角度に向けて回転させるか、位置に対面するように回転させます。

オプションの 2 つ目のパラメータは、追跡速度であり、これはスプライトが各フレームで目標の回転角度に移動する距離のパーセントです。デフォルトでは 0.1（10%）です。

# 7-5

`offset` プロパティを使用して、スプライトの物理ボディをその中心に対して移動させます。

`sprite.debug` が true のとき、スプライトの中心は小さな緑色の十字線で表示されます。中心点は、スプライトの x および y 座標がある場所です。また、これは回転の中心でもあります。

# 8-0

## 拡大縮小

`sprite.scale` を変更すると、指定された量でスプライトのコライダーと視覚的な外観がスケーリングされます。

数字キーを押すと、スプライトがその量だけ均一にスケールします。

"d"キーを押すと、スプライトのスケールが倍になります。

"x"キーまたは"y"キーを押すと、スプライトがその方向にランダムな量だけスケールします。ただし、スプライトが不均等にスケーリングされた場合、画像は歪んでしまい、再度均一にスケーリングされてもそのままになります。

# 9-0

## 物理挙動の属性

スプライトには、ワールドとの相互作用に影響を与える物理挙動の属性があります。これらの属性がどのように作用するかを見るために、コードサンプルをご覧ください。

# 9-1

## 質量

デフォルトでは、`mass` はスプライトのサイズに基づいて割り当てられます。スプライトが大きいほど、質量は多くなります。質量は手動で設定することもできます。

# 9-2

## やってみよう！

このコードサンプルの一つのスプライトの質量を変更してみてください。

# 9-3

## planck のバグ

p5play は planck 物理エンジンを使用していますが、通常は現実的に見える物理的相互作用を出力しますが、それは完全ではありません。

このコードサンプルでは、ボールは`bounciness`が 1 なので、ボールがバウンドするたびに、それはその開始位置に戻るはずです。しかし、planck のバグにより、ボールは地面に当たるたびに増加的に高く跳ねます。

# 9-4

planck か p5play の将来のバージョンでバグが修正されることを願っていますが、それまではここに一つの回避策を提供します。

`bounciness` のバグは、衝突体がフラットな面からバウンドするときに最も目立ちます。これは地面と衝突した後にボールの y 速度を上書きする回避策です。

# 9-5

この例では、ブロックが動くプラットフォームと衝突しているとき、その色は赤です。プラットフォームによって持ち上げられている間、ブロックが赤色のままであることを期待するかもしれませんが、赤と青の間で点滅します。

現実世界では、人がエレベーターに乗って上昇すると、その人がエレベーターの床と一緒に衝突すると言うでしょう。

しかし、planck では、衝突体が他の衝突体によって移動させられたとき、それらは互いに衝突し、解除されます。

もしプラットフォーマーゲームを作ろうとしているなら、スプライトがプラットフォームに立っているかどうかを判定する目的でコリジョンを利用するのは、おすすめできません。私の[プラットフォーマーデモ](https://openprocessing.org/sketch/1869796)をチェックしてみてください。

# 10-0

## 高度な動作

`move` 関数は強制的に、スプライトの速度を上書きします。しかし、スプライトが重力などの外力を考慮する必要がある場合はどうすれば良いでしょうか？

方位角（ベアリング）とは、「特定の位置に到達するために、力をかけるべき方向」のことです。スプライトの `bearing` を変更しても、その移動方向が即座に変更されるわけではありません。

`applyForce` 関数の引数に、力の量を与えることで、そのスプライトに与えていた `bearing` 角度への力が加わります。

この例では、ドローンは重力の力を克服して飛ばなければなりません。ドローンを飛ばし、それから落としてみてください。ドローンに再び上向きの力が加わると、落下が徐々に止まり、飛び始めます！

# 10-1

`applyForceScaled` 関数は、スプライトに適用される力をその質量で乗算します。位置は、x および y プロパティを持つオブジェクトとして与えることもできますし、個別の x と y パラメータとして与えることもできます。

この関数を使用して、スプライトに独自の重力を与えることができます！

両方の力関数は、力を個々の x および y 成分として受け入れるか、スプライトの `bearing` を設定することで量として受け入れることができます。

デフォルトでは、力はスプライトの重心に適用されます。ただし、`applyForce` および `applyForceScaled` 関数は、最後の入力パラメータとして、x と y プロパティを持つ位置オブジェクトも受け入れることができます。この位置オブジェクトは、どこに力をスプライトに適用するかの相対位置を指定します。

# 10-2

`attractTo` 関数は、引力を発生させ、他のスプライトを引き寄せることができます。

この例では、電子が原子核の周りを軌道を描いている様子をシミュレーションしています。

なお、このページで示されている高度な動作関数は、[スリーピングスプライト](./world.html) を起こすことはありません。

# 10-3

Torque （トルク）とは、転がりを引き起こす力のことです。スプライトが自然に転がるようにするには `applyTorque` を使います。

この例のように、ロボットの転がりは、上り坂のほうが下り坂よりも遅くなります。

# 11-0

## チェインコライダー

3 つの異なるチェインモードがあります：vertex、distance、および line。

vertex モードを使用するには、 Sprite コンストラクタに頂点配列の配列を提供します。各頂点配列は\[x, y\]座標を含むべきです。これらのコードサンプルでは、スプライトの(x, y)位置は小さな黒い四角で強調表示されています。

コードサンプルのチェインスプライトの頂点を変更して、ボールが床に留まるようにしてみてください！

# 11-1

distance モードを使用するには、 Sprite コンストラクタに(x, y)位置と distance 配列の配列を提供します。これらの配列は、前の頂点に対する\[x, y\]距離を含むべきです。(x, y)位置はチェインの最初の頂点になります。

distance モードは、とても長いチェインを作成するのに最適です。

5 つの距離を追加して、地面が起伏する岩地チェイン上で転がるようにしてみてください。

# 11-2

line モードを使用するには、 Sprite コンストラクタに(x,y)位置と線の長さと角度のリストを提供します。各角度は前の線の角度に対する相対値です。

line モードは、小さなおよび/または対称的なチェインに最適です。

line モードのチェインの(x, y)位置は、全ての頂点の平均に位置しますが、これはチェイン上の点ではないかもしれません。

これらの線の長さと角度を変更してみてください！

# 12-0

## ポリゴンコライダー

通常のポリゴンは、 Sprite コンストラクタに、一辺の長さと「ポリゴン名」を渡すことで生成できます。

ポリゴン名として使用できる文字列は次の通りです: `'triangle'` (三角形)、 `'square'` (四角形)、 `'pentagon'` (五角形)、 `'hexagon'` (六角形)、 `'septagon'` (七角形)、 `'octagon'` (八角形)、 `'enneagon'` (九角形)、 `'decagon'` (十角形)、 `'hendecagon'` (十一角形)、 `'dodecagon'` (十二角形)。

# 12-1

チェインの始点と終点が同じ座標で、かつ、結果として凸多角形となっていれば、それは自動的にポリゴンとなります！

# 12-2

スプライトが凸多角形のポリゴンなら `sprite.shape = 'chain'` で、強制的にチェインに変換できます。

# 12-3

すべてのポリゴン、および閉じたパスのシェイプのチェインは、（点座標の偏りにかかわらず、スプライトの）中心に配置されます。

# 12-4

これは、５つの頂点を持つ、一般的な星型を作るコードです。

星型は凹多角形であるため、ポリゴンコライダーを持つことはできないことに注意してください。

# 12-5

p5play のホームページにある、ロゴが回転するデモがどのように作られたか、これでおわかりいただけるでしょう！

閉じたチェインの内側は空洞でなので、より小さいスプライトをたくさん入れる「うつわ」として使うことができます。

# 12-6

閉じたチェインは、動的なコライダーとして使うには向いていないことに中止してください。

これは p5play が使用している Box2D 物理エンジンの制限です。代わりに「コンボコライダー」ページを参照して、複数の凸多角形コライダーをの組み合わせて凹多角形コライダーにする方法を検討してください。

# 13-0

## コンボコライダー

`addCollider`関数を使用すると、スプライトに複数のコライダーを追加することができます。

しかし、この機能は、ゲームプレイに本当に必要なときだけ使用してください！通常、迷路の壁のように多くのコライダーを必要とするものは、それぞれが独自のコライダーを持つ複数のスプライトを作成するべきです。また、スプライトの画像が複雑でも、通常はボックスや円で物理的な相互作用には十分で、特に小さなスプライトにはそれが適しています。

しかし、時には、本当に複数のコライダーを持つスプライトを作成する必要があります。例えば、ピンボールのフリッパーをモデル化したい場合などです！

# 13-1

## コンボセンサー

オーバーラップセンサーはスプライトが別のスプライトと重なっているかを判定します。

オーバーラップチェックのメソッドが使用されると、スプライトにセンサーがない場合、`addDefaultSensors`関数が背後で使用され、スプライトの各コライダーのためにセンサーが作成されます。

`addSensor`関数を使用して、スプライトに追加のセンサーを追加することができます。

# 14-0

## カスタム描画

スプライトの動きに対して求める視覚効果を得るために、事前に描かれたアニメーションを使用できない場合があります。

幸いなことに、スプライトの`draw`関数をカスタマイズして、任意の表示を行うことができます！

スプライトの draw 関数内部では、スプライトの中心が位置(0, 0)に移動されることに注意してください。

このコードサンプルでは、スプライトの楕円を移動方向に回転させ、その方向に比例して楕円を伸ばします。これはちょっと複雑です！

# 14-1

## カスタムアップデート

また、描画ループの終わりまたは `update` が呼ばれたときに実行されるスプライトのカスタムアップデート関数を定義することもできます。そこには、任意のスプライト固有の振る舞いを入れることができます。

# 15-0

## 移動のシーケンス化

これらの例では、ただの通常のスプライトである`Turtle`スプライトを使用しています。
それは緑色で、三角形になっていて、古典的なタートルプログラミングの見た目を持っています。

`async`関数内で`await`キーワードを使用すると、次の移動を続ける前に移動が終了するのを待つことができます。これは、スプライトを順番に動かすのに便利です。

# 15-1

`move`、`moveTo`、`rotate`、および`rotateTo`関数はすべて、移動が終了したときに true に解決する`Promise`を返します。

しかし、スプライトの移動が新しい移動またはスプライトの軌道を大幅に変更する衝突によって中断されると、promise は false に解決します。

# 15-2

スプライトを別のスプライトに追従させたい場合、`moveTo`を何度も使用し、スプライトが目的地に到達するのを待たないで使うことが考えられます。しかし、パフォーマンスを向上させるためには、`angleTo`関数を試してみてください。これは、スプライトと位置との間の角度を取得します。この角度は、スプライトが移動する方向を変更するために使用できます。

この例では、[p5.js dist](https://p5js.org/reference/#/p5/dist)関数が使用されて、プレイヤーとその味方との間の距離を計算しています。
