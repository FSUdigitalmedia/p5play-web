<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>p5play : Sprite</title>
	<link rel="icon" href="../logo.svg" />
	<link rel="stylesheet" href="style.css">
</head>

<body class="dark">
	<article>
		<nav id="topNav">
			<a href="index.html" id="logoLink" class="active">
				<img alt="p5play logo" src="../logo.svg" class="logo">
				<span>p5play</span>
			</a>
			<hr>
			<a href="sprite.html" class="active">Sprite</a>
			<a href="group.html">Group</a>
			<a href="sprite_animation.html">Animation</a>
			<a href="input_devices.html">Input</a>
			<a href="tiles.html">Tiles</a>
			<a href="camera.html">Camera</a>
			<a href="advanced.html">Adv</a>
			<hr>
			<a id="darkMode" onclick="toggleDarkMode()" tabindex="0" role="button">
				<div id="darkModeIcon"></div>
			</a>
		</nav>

		<div class="break"></div>

		<div id="page-0" class="page">
			<div>
				<h2>Setup</h2>
				<p>
					The code inside the p5.js (or q5.js) <code>setup</code> function runs
					when the program starts. The <code>new Canvas()</code> constructor
					creates a section of the screen that the program can draw on.
				</p>
				<p>
					The p5.js <code>draw</code> function is run 60 times per second by
					default. The <code>background</code> function can be used to fill the canvas with a color each time it is
					drawn.
				</p>
				<p>
					Try changing the width and height of the canvas (the numbers inside the <code>Canvas</code> constructor), then
					restart the example program!
				</p>
			</div>
			<script type="mie/p5" name="p5.js setup and draw">
function setup() {
	new Canvas(250, 100);
}

function draw() {
	background('blue');
}
		</script>
			<div class="break"></div>
			<div>
				<h2>What is a sprite?</h2>
				<p>
					A sprite is a ghost!
				</p>
				<p>
					Video game developers use the word "sprite" to refer to
					characters, items, or anything else that moves above a background.
				</p>
				<p>
					The <code>new Sprite()</code> constructor creates a sprite.
				</p>
				<p>
					Try editing the properties of the box and circle sprites in the
					mini examples below!
				</p>
			</div>
			<div class="minis horiz">
				<script type="mie/p5" name="box" base-0 horiz lines="9">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.width = 50;
	sprite.height = 50;
}

function draw() {
	clear();
}
			</script>
				<script type="mie/p5" name="circle" base-1 horiz lines="8">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.diameter = 50;
}

function draw() {
	clear();
}
			</script>
			</div>
			<div class="minis">
				<script type="mie/p5" name="x">
				sprite.x = 150;
			</script>
				<script type="mie/p5" name="y" base="1">
				sprite.y = 30;
			</script>
				<script type="mie/p5" name="position">
				sprite.pos = {x: 50, y: 0};
			</script>
				<script type="mie/p5" name="rotation">
				sprite.rotation = 45;
			</script>
				<script type="mie/p5" name="color" base="1">
sprite.color = 'pink';
sprite.stroke = 'red';
			</script>
				<script type="mie/p5" name="textColor">
sprite.textColor = 'blue';
sprite.text = "Hello!";
			</script>
			</div>

			<div class="minis">
				<script type="mie/p5" name="width">
				sprite.w = 200;
			</script>
				<script type="mie/p5" name="height">
				sprite.h = 80;
			</script>
				<script type="mie/p5" name="diameter" base="1">
				sprite.d = 40;
			</script>
				<script type="mie/p5" name="radius">
				sprite.r = 40;
			</script>
				<script type="mie/p5" name="textSize">
sprite.textSize = 40;
sprite.text = "p5";
			</script>
				<script type="mie/p5" name="visible">
				sprite.visible = false;
			</script>
			</div>
			<div class="break"></div>
			<div class="minis horiz">
				<script type="text/md">
## Try it out!

Try turning the sprite named <code>ball</code> into a blue circle with a diameter of 30 and place it at the top right corner of the canvas.

				</script>
				<script type="mie/p5" name="Level 0 Challenge Solution" hide-editor>
let ball;

function setup() {
	new Canvas(500, 60);
	ball = new Sprite();
	ball.diameter = 30;
	ball.color = 'blue';
	ball.x = 480;
	ball.y = 16;
}

function draw() {
	clear();
}
			</script>
			</div>
			<script type="mie/p5" name="Level 0 Challenge" lines="13" horiz>
let ball;

function setup() {
	new Canvas(200, 256);
	ball = new Sprite();
	// write your code here!
  
}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-1" class="page">
			<script type="text/md">
## Sprite physics

A sprite's collider is used to detect collisions with other
sprites. By default, sprites have a `'dynamic'` physics
collider that allows the sprite to move freely and be affected by
gravity.

`'static'` colliders can't be moved. `'kinematic'` colliders can be moved 
programmatically but not by other sprites. They also won't collide with other kinematic colliders. Setting a sprite's collider
type to `'none'` removes it from the physics simulation.

The collider type can also be set using the first letter of the collider type name: `'d'`, `'s'`, `'k'`, or `'n'`.

Click the reload icon on the top right corner of a mini example to replay it!
			</script>
			<script type="mie/p5" name="dynamic and static colliders" base-2 horiz lines="16">
let ball, floor;

function setup() {
	new Canvas(238, 200);
	world.gravity.y = 10;

	ball = new Sprite();
	ball.diameter = 50;
	ball.y = 30;

	floor = new Sprite();
	floor.y = 190;
	floor.w = 238;
	floor.h = 5;
	floor.collider = 'static';
}

function draw() {
	clear();
}
			</script>
			<div class="minis">
				<script type="mie/p5" name="anti-gravity" base="2">
world.gravity.y = -1;
				</script>
				<script type="mie/p5" name="sloped floor" base="2">
floor.rotation = 2;
				</script>
			</div>

			<div class="minis">
				<script type="mie/p5" name="rising platform" base="2">
floor.collider = 'k';
floor.velocity.y = -1;
				</script>
				<script type="mie/p5" name="whoops!" base="2">
floor.collider = 'none';
				</script>
			</div>
			<div class="break"></div>
			<div>
				<script type="text/md">
## Try it out!

Try creating a sprite named `peg` with a static collider and circle shape. Create a sprite `block` with a dynamic collider and box shape. Make the block fall from above and hit the peg, falling to the right side.

Note that `world` is created when p5play loads but by default there is no gravity. Try setting `world.gravity.y` to a positive number. Each time the p5.js `draw` function finishes, sprites are automatically drawn and updated by default.
				</script>
				<script type="mie/p5" name="Level 1 Challenge Solution" hide-editor>
let peg, block;

function setup() {
	new Canvas(460, 60);
	world.gravity.y = 10;

	peg = new Sprite();
	peg.diameter = 10;
	peg.y = 40;
	peg.collider = 'static';

	block = new Sprite();
	block.w = 30;
	block.h = 30;
	block.x = 236;
	block.y = 0;
}

function draw() {
	clear();
}
				</script>
			</div>
			<script type="mie/p5" name="Level 1 Challenge" lines="13" horiz>
let peg, block;

function setup() {
	new Canvas(200, 256);

}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-2" class="page">
			<script type="mie/p5" name="idle player" lines="11" hide base-3>
let player, block;

function setup() {
	new Canvas(500, 100);

	player = new Sprite();
	player.diameter = 50;
	player.x = 400;

	block = new Sprite();
}

function draw() {
	clear();
}
			</script>
			<div>
				<h2>Sprite movement</h2>
				<p>
					Changing a sprite's position teleports it!
				</p>
				<p>
					Try clicking around this mini-example.
				</p>
			</div>
			<script type="mie/p5" name="teleport" base="3">
if (mouse.presses()) {
	player.x = mouse.x;
	player.y = mouse.y;
}
			</script>
			<div>
				<p>
					The next example shows what happens if a sprite is teleported
					every time the p5.js draw function renders a frame.
				</p>
				<p>
					If you want a sprite to physically interact with other sprites while it's moving, don't teleport it!
				</p>
			</div>
			<script type="mie/p5" name="teleport (continuously) ðŸ‘Ž" base="3">
player.x = mouse.x;
player.y = mouse.y;
			</script>
			<div>
				<p>
					All of the other movement examples on this page are based on
					changing the sprite's x and y axis
					velocities.
					<code>velocity</code> aka <code>vel</code> is
					a p5.js Vector, you can use any Vector functions on it.
				</p>
				<p>
					You may have to restart this example to see the sprite move.
				</p>
			</div>
			<script type="mie/p5" name="velocity (continuously)" base="3">
player.vel.x = -2;
player.vel.y = 0.1;
			</script>
			<div>
				<p>
					Move the sprite indefinitely by setting its <code>direction</code> and <code>speed</code>.
				</p>
				<p>
					You can also set a sprite's direction using a direction name such as:
					'up', 'down', 'left', 'right', 'upLeft', 'upRight',
					'downLeft', 'downRight'.
				</p>
				<p>
					Note that p5play converts these direction names to their corresponding angle values.
				</p>
			</div>
			<script type="mie/p5" name="direction + speed (continuously)" base="3">
player.direction = 187;
player.speed = 3;
			</script>
			<div>
				<p>
					The <code>move</code> function moves a sprite across a fixed
					distance. The direction and speed of the movement can
					be specified as parameters to the function or set separately.
				</p>
			</div>
			<script type="mie/p5" name="move (impulse)" base="3">
if (kb.presses('left')) {
	//   (distance, direction, speed)
	player.move(30, 'left', 3);
}
			</script>
			<div>
				<p>
					The <code>moveTowards</code> function moves a sprite towards a
					position, at a percentage of the distance to that position.
				</p>
				<p>
					In this example, the player moves 10% of the distance to
					the mouse on every p5.js draw call. Its speed, and the force
					it exerts on the block, is proportional to the distance it
					moves.
				</p>
			</div>
			<script type="mie/p5" name="moveTowards (continuously)" base="3">
//             (position, tracking)
player.moveTowards(mouse, 0.10);
			</script>
			<div>
				<p>
					The <code>moveTo</code> function generates an impulse that moves a sprite to a position at a constant speed.
				</p>
				<p>
					But note that if the sprite is acted on by a force like gravity or bumps into another sprite, its speed and
					direction
					will be affected and it may not reach the
					target position.
				</p>
				<p>
					Any movement function that accepts an
					object with x and y properties could instead be called with
					(x, y) position numbers.
				</p>
			</div>
			<script type="mie/p5" name="moveTo (impulse)" base="3">
if (mouse.presses()) {
	//        (position, speed)
	player.moveTo(mouse, 8);
}
			</script>
			<div>
				<p>
					The <code>angleTo</code> function gets the angle between
					the sprite and a position.
				</p>
				<p>
					If you're tempted to use <code>moveTo</code> repeatedly, without
					waiting for the sprite to reach its target, consider using
					this approach instead for better performance.
				</p>
				<p>
					Restart this example to see the sprite move.
				</p>
			</div>
			<script type="mie/p5" name="angleTo" base="3">
if (mouse.pressing()) {
	player.direction = player.angleTo(mouse);
	player.speed = 3;
}
			</script>
			<div>
				<p>
					Hopefully the examples on this page helped you understand some of the movement options available in p5play.
					But,
					they're just building blocks for more complex movement patterns.
				</p>
				<p>
					You'll often need to experiment with them in creative ways
					to find the best solutions for your game!
				</p>
			</div>
			<script type="mie/p5" name="segmented motion" base="3">
if (kb.pressing('left')) player.vel.x = -5;
else if (kb.pressing('right')) player.vel.x = 5;
else player.vel.x = 0;
			</script>
		</div>
		<div id="page-3" class="page">
			<script type="text/md">
## Sprite image

`sprite.image` or `sprite.img` can be set to a p5.Image or a url path to an image file.

If you need an image to be loaded before your program starts, it's best to use [`loadImage`](https://p5js.org/reference/#/p5/loadImage) inside the p5.js `preload` function.

`sprite.scale` changes the size of both the sprite's collider and visual appearance. A scale value of 2 doubles the size of the sprite.

Try pressing the left mouse button. When the `sprite.debug` property is set to true you can see the sprite's physics body collider. You can make the size of the collider different from the size of the image!
			</script>
			<script type="mie/p5" name="image">
let monster;

function setup() {
	new Canvas(500, 120);

	monster = new Sprite();
	monster.img = 'assets/monster.png';
	monster.diameter = 70;
}

function draw() {
	clear();
	if (kb.presses(2)) {
		monster.scale = 2;
	}
	monster.debug = mouse.pressing();
}
			</script>
			<script type="text/md">
## Make Pixel Art!
			
You can use the `spriteArt` function to create pixel art images for your sprites. It takes a string as input and returns an image. Each character in the string represents the color value of a pixel in the image.

The second input parameter to the `spriteArt` function is the scale of the image.
			</script>
			<script type="mie/p5" name="smiley" lines="15">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..yyyyyy
.yybyybyy
yyyyyyyyyy
yybyyyybyy
.yybbbbyy
..yyyyyy`;

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 16);
}

function draw() {
	clear();
}
			</script>
			<div>
				<p>
					The default palette uses p5.js default colors but you can change the color palette too!
				</p>
			</div>
			<script type="mie/p5" name="blue smiley" lines="20">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..yyyyyy
.yybyybyy
yyyyyyyyyy
yybyyyybyy
.yybbbbyy
..yyyyyy`;

	let palette = {
		'y': color(60, 220, 255),
		'b': color(20)
	};

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 16, palette);
}

function draw() {
	clear();
}
					</script>
		</div>
		<div id="page-4" class="page">
			<div>
				<script type="text/md">
## Create Sprites faster

Inside the Sprite constructor, `new Sprite()`, you can specify the sprite's position, size, and collider type.

As you saw on the previous Sprite reference pages, you don't need to add any inputs to the Sprite constructor to create a sprite. But, if you do want to set a sprite's size in the constructor you'll need to specify its position first.

By default, if no inputs are given to the Sprite constructor, new sprites are positioned at the center of the canvas, with a width and height of 50 pixels, and a dynamic collider.
				</script>
				<script type="mie/p5" name="default sprite" lines="3" horiz>
function setup() {
	new Sprite();
}

function draw() {
	clear();
}
				</script>
			</div>
			<div class="minis horiz">
				<script type="mie/p5" name="Ooo!" horiz lines="18">
let box, circle;

function setup() {
	new Canvas(50, 200);
	world.gravity.y = 10;

	//             	( x,  y,  w,  h, collider)
	box = new Sprite(25, 70, 10, 90, 'static');
	// same as setting the values separately
	// box.x = 25;
	// box.y = 70;
	// box.width = 10;
	// box.height = 90;
	// box.collider = 'static';

	// 					 	     ( x,   y,  d, collider)
	circle = new Sprite(25, 140, 10, 'static');
}

function draw() {
	clear();
}
				</script>
				<script type="mie/p5" name="ball on the floor" lines="10" horiz>
let ball, floor;

function setup() {
	new Canvas(80, 160);
	world.gravity.y = 10;
	
	ball = new Sprite(40, 30, 50);

	floor = new Sprite(40, 155, 80, 5, 'static');
}

function draw() {
	clear();
}
				</script>
			</div>
			<div class="break"></div>
			<div>
				<h2>Try it out!</h2>
				<p>
					Try creating two sprites using the sprite constructor.
				</p>
			</div>
			<script type="mie/p5" name="Level 4 Challenge" lines="13" horiz>
let sprite1, sprite2;

function setup() {
	new Canvas(50, 256);

}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-5" class="page">
			<script type="text/md">
## collides, colliding, and collided

On the first frame that a sprite collides with another sprite, the `collides` function returns true.

While a sprite is colliding with another sprite, the `colliding` function returns the number of frames the collision has occurred for.

On the first frame after two sprites collided, the `collided` function returns true.
			</script>
			<script type="mie/p5" name="pillar stomp!" horiz>
let player, pillar;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	pillar = new Sprite(30, 362, 30, 500, 'static');
	player = new Sprite(30, 0, 50);
}

function draw() {
	clear();

	if (player.collides(pillar)) {
		player.vel.y = -5;
		pillar.h -= 52;
	}
}
			</script>
			<script type="mie/p5" name="drop block" horiz>
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
	floor.color = 'red';
}

function draw() {
	clear();
	if (block.colliding(floor)) {
		block.color = 'red';
	} else block.color = 'blue';

	if (block.colliding(floor) > 60) {
		block.vel.y = -9;
	}
}
			</script>
			<script type="mie/p5" name="break floor" horiz>
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
}

function draw() {
	clear();
	if (block.collided(floor)) {
		floor.collider = 'dynamic';
	}
}
			</script>
		</div>
		<div id="page-6" class="page">
			<div>
				<h2>Overlap</h2>
				<p>Sprites collide by default but they can also overlap!</p>
			</div>
			<script type="mie/p5" name="overlap" horiz lines="8" base-4>
function setup() {
	new Canvas(200, 128);

	sprite1 = new Sprite(90, 50);
	sprite2 = new Sprite(115, 75);

	sprite1.overlaps(sprite2);
}

function draw() {
	clear();
}
			</script>
			<div>
				<h2>Layer</h2>
				<p>By default sprites are drawn in the order they were created in. You can change the draw order by editing
					sprite's <code>.layer</code> property. Sprites with the highest layer value get drawn first.</p>
			</div>
			<script type="mie/p5" name="layer" horiz lines=8 base=4>
sprite1.layer = 2;
sprite2.layer = 1;
			</script>
			<script type="text/md">
## overlaps, overlapping, and overlapped

On the first frame that a sprite overlaps with another sprite, the `overlaps` function returns true.

While a sprite is overlapping with another sprite, the `overlapping` function returns the number of frames the overlap has occurred for.

On the first frame after two sprites overlapped, the `overlapped` function returns true.

Note that physical interactions between sprites, including collisions and overlaps, can't be properly detected when a
sprite is teleported, its position is directly changed!
			</script>
			<script type="mie/p5" name="collect coin">
let player, coin;

function setup() {
	new Canvas(500, 100);

	coin = new Sprite(400, 50, 30);
	coin.color = 'yellow';
	player = new Sprite(50, 50);
}

function draw() {
	clear();
	player.moveTowards(mouse);
		
	if (player.overlaps(coin)) coin.remove();
}
			</script>
			<div class="break"></div>
			<div>
				<h2>Try it out!</h2>
				<p>
					Try making the blue sprite change to red only if it's overlapping with the red sprite.
				</p>
			</div>
			<script type="mie/p5" name="Level 6 Challenge" lines="20" horiz>
let sprite1, sprite2;

function setup() {
	new Canvas(100, 400);
	sprite1 = new Sprite(50, 50);
	sprite1.color = 'blue';
	sprite2 = new Sprite(50, 300);
	sprite2.color = 'red';
}

function draw() {
	clear();
	sprite1.moveTowards(mouse);

	
	
}
			</script>
			<div class="break"></div>
			<div>
				<h2>Switch between overlaps and collides</h2>
				<p>
					By default if you check for an overlap between two sprites,
					they will no longer collide. You can override
					this by checking for a collision between the sprites.
				</p>
				<p>
					In this example, pressing the space key temporarily allows the player to ghost through the wall.
				</p>
			</div>
			<script type="mie/p5" name="ghost ability">
let player, wall;

function setup() {
	new Canvas(500, 100);

	wall = new Sprite(250, 50, 30, 400, 's');
	wall.color = 'purple';
	player = new Sprite(50, 50);
}

function draw() {
	clear();
	player.moveTowards(mouse);

	if (kb.pressing('space')) {
		player.overlaps(wall);
		player.color = 'purple';
	} else {
		player.collides(wall);
		player.color = 'orange';
	}
}

			</script>
		</div>
		<div id="page-7" class="page">
			<script type="mie/p5" base-5 hide>
let sprite;

function setup() {
	new Canvas(238, 80);

	sprite = new Sprite();
	sprite.h = 20;
}

function draw() {
	clear();
}
			</script>
			<div>
				<h2>Sprite rotation</h2>
				<p>
					Directly changing the <code>rotation</code> property of a sprite will teleport it to the specified rotation
					angle.
				</p>
				<p>
					Don't teleport a sprite if you want it to physically interact with other sprites while it's rotating!
				</p>
			</div>
			<script type="mie/p5" name="rotation (teleport)" base="5">
if (kb.pressing('space')) sprite.rotation = 90;
else sprite.rotation = 0;
			</script>
			<div>
				<p>
					Changing the sprite's <code>rotationSpeed</code> directly is useful for sprites that rotate indefinitely.
				</p>
			</div>
			<script type="mie/p5" name="rotationSpeed" base="5">
sprite.rotationSpeed = 1;
			</script>
			<div>
				<p>
					Use the <code>rotate</code> function to rotate a sprite by an amount.
				</p>
				<p>
					The optional second parameter is the speed at which the sprite rotates per frame. Try changing the speed of
					rotation in this mini example.
				</p>
			</div>
			<script type="mie/p5" name="rotate" base="5">
//                                 (angle, rotationSpeed)
if (kb.presses('left')) sprite.rotate(-45, 3);
if (kb.presses('right')) sprite.rotate(45, 3);
			</script>
			<div>
				<p>
					Use the <code>rotateTo</code> function to rotate a sprite so that it faces a position, which can also be
					given
					in (x, y) coordinates. The optional
					parameter following the position is the
					rotation speed. The
					optional parameter at the end is the angle at which the sprite should be facing the target position.
				</p>
				<p>
					Try setting the second parameter to 90! When you click, the long side of the sprite will rotate to face the
					mouse.
				</p>
			</div>
			<script type="mie/p5" name="rotateTo" base="5">
//                     (position, rotationSpeed, facing)
if (mouse.presses()) sprite.rotateTo(mouse, 5, 0);
			</script>
			<div>
				<p>
					Use the <code>rotateTowards</code> function to rotate a sprite towards a position. The optional parameter
					after
					the position is the tracking speed, a percent of the
					distance the sprite moves on each frame to the target rotation angle, 0.1 (10%) by default.
				</p>
			</div>
			<script type="mie/p5" name="rotateTowards" base="5">
//           (position, tracking, facing)
sprite.rotateTowards(mouse, 0.1, 0);
			</script>

		</div>
		<div id="page-8" class="page">
			<script type="text/md">
## Movement sequencing

These examples use a `Turtle` sprite which is just a regular sprite 
that's green and shaped like a triangle for that classic turtle 
programming look.

You can wait for a movement to finish before continuing with the next movement. This is useful for making a sprite move in a sequence.
			</script>
			<script type="mie/p5" name="square sequence" horiz lines="14">
let turtle;

function setup() {
	new Canvas(160, 160);
	turtle = new Turtle(30);

	squareSequence();
}

async function squareSequence() {
	await turtle.move(100);
	await turtle.rotate(90);
	squareSequence();
}

function draw() {
	clear();
}
			</script>
			<script type="text/md">
The `move`, `moveTo`, `rotate`, and `rotateTo` functions all return a promise that resolves when the movement is finished. You can use the `await` keyword to wait for the promise to resolve before continuing with the next movement.
			</script>
			<script type="mie/p5" name="random sequence" horiz lines="16">
let turtle;

function setup() {
	new Canvas(160, 304);
	turtle = new Turtle(30);

	randomSequence();
}

async function randomSequence() {
	let x = random(0, width);
	let y = random(0, height);
	await turtle.rotateTo(x, y, 5);
	await turtle.moveTo(x, y, 5);
	randomSequence();
}

function draw() {
	clear();
}
			</script>
			<!-- <script type="mie/p5" name="move sequence" horiz>
let turtle;

function setup() {
	new Canvas(160, 400);
	turtle = new Sprite(30, 30, 25, 25);
	turtle.color = 'red';

	exampleSequence();
}

async function exampleSequence() {
	while (true) {
		await turtle.rotate(90, 2);
		await turtle.move('up', 2, 50);
	}
}

function draw() {
	clear();
}
		</script> -->
		</div>
		<div id="page-9" class="page">
			<script type="text/md">
## Physical attributes

Sprites have physical attributes that affect how they interact with the world. Take a look at the mini-examples to see these attributes in action.
			</script>
			<script type="mie/p5" base-6 hide>
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function draw() {
	clear();
}
			</script>
			<script type="mie/p5" base-7 hide>
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function draw() {
	clear();
}
			</script>
			<div class="minis">
				<script type="mie/p5" name="low bounciness" base="7">
sprite.bounciness = 0.5;
				</script>
				<script type="mie/p5" name="full bounciness" base="7">
sprite.bounciness = 1;
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" name="0 friction" base="6">
sprite.friction = 0;
				</script>
				<script type="mie/p5" name="high friction" base="6">
sprite.friction = 10;
				</script>
				<script type="mie/p5" name="0 drag" base="6">
sprite.drag = 0;
				</script>
				<script type="mie/p5" name="high drag" base="6">
sprite.drag = 10;
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" name="low rotationDrag" base="7">
sprite.rotationDrag = 1;
				</script>
				<script type="mie/p5" name="high rotationDrag" base="7">
sprite.rotationDrag = 5;
				</script>
				<script type="mie/p5" name="no rotationLock" base="7">
sprite.rotationLock = false
				</script>
				<script type="mie/p5" name="with rotationLock" base="7">
sprite.rotationLock = true;
				</script>
			</div>
			<div>
				<p>
					By default, <code>mass</code> is assigned based on the sprite's size. The larger the sprite, the more mass
					it
					has. Mass can
					also be set manually.
				</p>
				<p>
					Try changing the mass of one of the sprites in this mini-example.
				</p>
			</div>
			<script type="mie/p5" name="mass" lines="13">
let platform, pin, a, b;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;

	platform = new Sprite(121, 88, 232, 5);
	pin = new Sprite(121, 93, 5, 's');

	a = new Sprite(26, 0, 40, 40);
	a.mass = 2;
	b = new Sprite(216, 0, 40, 40);
	b.mass = 2;
}
function draw() {
	clear();
}
			</script>
			<div class="break"></div>
			<div>
				<h2>planck Bugs</h2>
				<p>
					p5play uses the planck physics engine, which usually outputs realistic looking physical
					interactions, but it's not perfect.
				</p>
				<p>
					In this mini-example the ball has a <code>bounciness</code> of 1, so each time the ball bounces it should
					return to its starting position. However, due to a bug in planck, the ball bounces incrementally higher each
					time it hits the ground.
				</p>
			</div>
			<script type="mie/p5" name="full bounce error" lines="10" horiz>
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function draw() {
	background(0);

	fill(100);
	for (let i = 0; i < width / 32; i++) {
		for (let j = 0; j < height / 32; j++) {
			rect(i * 32, j * 32, 32, 32);
		}
	}
}
			</script>
			<div>
				<p>
					Hopefully the bug will be fixed in a future version of planck or p5play, but until then here's a workaround.
				</p>
				<p>
					The <code>bounciness</code> bug is most noticeable when a collider bounces off a flat surface. Here's a
					workaround
					that overrides the ball's y velocity after it collides with the ground.
				</p>
			</div>
			<script type="mie/p5" name="full bounce workaround" horiz>
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function draw() {
	clear();

	if (ball.collided(ground)) {
		ball.vel.y = -4.8;
	}
}
			</script>
			<div>
				<p>
					Also, you may expect <code>friction</code> to affect circle physics colliders, but sadly it doesn't! Use the
					<code>rotationDrag</code> property instead.
				</p>
			</div>
			<div class="minis">
				<script type="mie/p5" name="circle friction?" base="7">
sprite.friction = 500;
			</script>
				<script type="mie/p5" name="circle rotationDrag" base="7">
sprite.rotationDrag = 5;
			</script>
			</div>
			<script type="text/md">
In this example the block's color is red when it is colliding with the moving platform. Although you might expect the block to stay red while being lifted by the platform, it blinks between red and blue.

In real life when a person gets on an elevator and it rises, we would say that person would be colliding with the elevator floor the whole ride.

In planck however, when colliders are displaced by other colliders, they constantly collide and uncollide with each other.

			</script>
			<script type="mie/p5" name="colliding bug" horiz>
let block, platform;

function setup() {
	new Canvas(60, 400);
	world.gravity.y = 10;

	block = new Sprite(30, 30);
	platform = new Sprite(30, 200, 60, 5, 'k');
	platform.color = 'red';
}

function draw() {
	clear();
	platform.vel.y = cos(frame * 2.2) * 6;

	if (block.colliding(platform)) {
		block.color = 'red';
	} else {
		block.color = 'blue';
	}
}

			</script>
		</div>
		<div id="page-10" class="page">
			<div>
				<h2>Chain Colliders</h2>
				<p>
					There are three different chain modes: vertex, distance, and line.
				</p>
				<p>
					To use vertex mode, provide the Sprite constructor with an array
					of vertex arrays. Each vertex array should contain [x, y]
					coordinates. In these
					mini-examples the sprite's (x, y) position is highlighted by a small black square.
				</p>
				<p>
					Try changing the vertexes of the chain sprite in the mini-example
					to make the ball stay on the floor!
				</p>
			</div>
			<script type="mie/p5" name="vertex mode" lines="12">
let floor, ball;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                ([vertex0, vertex1, vertex2, ...])
	floor = new Sprite([[20, 60], [200, 140], [450, 180]]);
	floor.collider = 'static';

	ball = new Sprite(40, 0, 20);
}

function draw() {
	clear();
	rect(floor.x - 2, floor.y - 2, 4, 4);
}
			</script>
			<div>
				<p>
					To use distance mode, provide the Sprite constructor an (x, y) position and an array of distance arrays.
					These
					arrays should contain [x, y] distances relative to the previous vertex. The (x, y) position will be the
					first
					vertex in the chain.
				</p>
				<p>
					Distance mode is best for creating super long chains.
				</p>
				<p>
					Try adding 5 distances to make the ground roll up and down on a rocky ground chain.
				</p>
			</div>
			<script type="mie/p5" name="distance mode" lines="12">
let ground, ball;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                 (x, y, [distance0, distance1, ...])
	ground = new Sprite(30, 90, [[20, 20], [60, -10], [50, 10]], 'static');

	ball = new Sprite(40, 0, 20);
}
	
function draw() {
	clear();
	rect(ground.x - 2, ground.y - 2, 4, 4);
}
			</script>

			<div>
				<p>
					To use line mode, provide the Sprite constructor an (x,y) position and a list of line lengths and angles.
					Each
					angle is relative to the previous line's angle.
				</p>
				<p>
					It's best to use line mode for small
					and/or
					symmetrical chains.
				</p>
				<p>
					Note that the line mode chain's (x, y) position is located at
					the average of all its vertices, which may not be a point on the chain.
				</p>
				<p>
					Try changing the lengths of these lines and their angles!
				</p>
			</div>
			<script type="mie/p5" name="line mode" lines="12">
let shelf, orb;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                (x, y, [length0, angle0, length1, ...])
	shelf = new Sprite(250, 100, [50, 20, 50, -20, 50, -20], 'static');

	orb = new Sprite(200, 0, 20);
}
	
function draw() {
	clear();
	rect(shelf.x - 2, shelf.y - 2, 4, 4);
}
		</script>
		</div>
		<div id="page-11" class="page">
			<div>
				<h2>Polygon Colliders</h2>
				<p>
					Regular polyons can be created by providing the Sprite constructor with a side length and the name of the
					polygon.
				</p>
				<p>
					Here are the names you can use: triangle, square, pentagon, hexagon, septagon, octagon, enneagon,
					decagon, hendecagon, and
					dodecagon.
				</p>
			</div>
			<script type="mie/p5" name="pentagon" lines="6">
function setup() {
	new Canvas(500, 200);

	//        ( x,  y, sideLength, polygonName)
	new Sprite(250, 100, 80, 'pentagon');
}
	
function draw() {
	clear();
}
			</script>
			<div>
				<p>
					If the start and end of a chain is at the same point and the resulting shape is convex, it automatically
					becomes
					a polygon!
				</p>
			</div>
			<script type="mie/p5" name="irregular polygon: vertex mode" lines="5">
function setup() {
	new Canvas(500, 200);

	new Sprite([[8, 8], [140, 192], [300, 90], [8, 8]]);
}

function draw() {
	clear();
}
			</script>
			<div>
				<p>
					Regardless of whether a sprite is a polygon or a chain, all
					physics bodies that start and end at the same point have their
					(x, y) position located at the center of the shape, not at the
					first vertex. This position is calculated by averaging all of the
					shape's vertexes.
				</p>
			</div>
			<script type="mie/p5" name="irregular polygon: distance mode" lines="9">
function setup() {
	new Canvas(500, 200);

	new Sprite(250, 100, [
		[100, 40],
		[-100, 40],
		[0, -80]
	]);
}

function draw() {
	clear();
}
			</script>
			<div>
				<p>
					You can force a convex polygon to be a chain by setting <code>sprite.shape = 'chain'</code>
				</p>
				<p>
					Regular polygons can be created from a list with the line length,
					angle, and repeat.
				</p>
				<p>
					The formula for the angle of
					a regular polygon is 360 / n, where n is the number of sides. Make
					that angle negative to orient the polygon with one of its edges on top.
				</p>
				<p>
					Try making a square shaped chain!
				</p>
			</div>
			<script type="mie/p5" name="pentagon chain" lines="7">
function setup() {
	new Canvas(500, 200);

	//               (x, y, [length, angle, repeat])
	let s = new Sprite(250, 100, [80, -72, 5]);
	s.shape = 'chain';
}
	
function draw() {
	clear();
}
			</script>
			<div>
				<p>
					Here's the code for making a regular star with five points.
				</p>
				<p>
					Note that because the star is a concave shape it can't have a polygon collider.
				</p>
				<p>
					Try changing the number of points!
				</p>
			</div>
			<script type="mie/p5" name="star" lines="6">
function setup() {
	new Canvas(500, 200);

	//        ( x,  y, [l0, a0, l1, a1, repeat])
	new Sprite(250, 100, [60, -72, 60, 144, 5]);
}

function draw() {
	clear();
}
			</script>
			<div>
				<p>
					Now you can see how the p5play logo was made!
				</p>
				<p>
					Even closed chains like this one are made of lines and
					they're empty on the inside. In the example on the p5play
					homepage, you can see how chain
					colliders can contain many other sprites inside them!
				</p>
			</div>
			<script type="mie/p5" name="p5play logo" lines="8">
function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	new Sprite(250, 100, [40, 72, 40, -72, 40, 72, 5], 's');

	new Sprite(251, 50, 20, 'pentagon');
}

function draw() {
	clear();
}
			</script>
			<div>
				<p>
					Note that closed chain colliders aren't so good at being dynamic colliders. This is a
					limitation of the Box2D physics engine that p5play uses.
				</p>
			</div>
			<script type="mie/p5" name="concave chain colliders" lines="11">
function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	new Sprite([
		[200, 50],
		[300, 50],
		[300, 100],
		[280, 70],
		[200, 50]
	]);

	new Sprite(250, 190, 500, 10, 's');
}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-12" class="page">
			<div>
				<h2>Custom draw</h2>
				<p>
					Sometimes you won't be able to use pre-drawn animations to get
					the kind of visual effect you want for a sprite in motion.
				</p>
				<p>
					Fortunately, you can customize the sprite's <code>draw</code> function
					and make it display anything you want!
				</p>
				<p>
					Note that inside the sprite's draw function the center of the sprite
					is translated to position (0, 0).
				</p>
				<p>
					This mini example rotates the sprite's ellipse to the direction it's moving and makes the ellipse stretch in
					that direction
					proportional to it's speed. Kind of complicated!
				</p>
				<h2>Custom Update</h2>
				<p>
					You can also define a custom update function for a sprite that runs at the end of the draw loop or when
					updateSprites is called. You can put any sprite specific behavior you want in there.
				</p>
			</div>
			<script type="mie/p5" name="custom draw">
let face, stretchy;

function setup() {
	new Canvas(500, 200);

	face = loadImage('assets/face.png');
	stretchy = new Sprite();
	
	stretchy.draw = () => {
		fill(237, 205, 0);

		push();
		rotate(stretchy.direction);
		ellipse(0, 0, 100 + stretchy.speed, 100 - stretchy.speed);
		pop();

		image(face, stretchy.vel.x * 2, stretchy.vel.y * 2);
	};

	stretchy.update = () => {
		stretchy.moveTowards(mouse, 0.07);
	};
}

function draw() {
	clear();
}
//
			</script>
		</div>
		<div id="page-13" class="page">
			<script type="text/md">
## scale

Changing `sprite.scale` will scale the sprite's collider and visual appearance by the specified amount.

Press a number key to see the sprite scale uniformly by that amount.

Press "d" to double the sprite's scale.

Press "x" or "y" to scale the sprite in that direction by a random amount. But note that if the sprite gets scaled unevenly, the image will get distorted and stay that way even when scaled uniformly again.
			</script>
			<script type="mie/p5">
let sprite;

function setup() {
	new Canvas(500, 200);

	sprite = new Sprite(250, 100, 90, 90);
	sprite.img = 'assets/square.png';
	sprite.debug = true;
}

function draw() {
	clear();

	for (let i = 1; i < 10; i++) {
		if (kb.presses(i)) sprite.scale = i;
	}

	if (kb.presses('d')) sprite.scale *= 2;
	if (kb.presses('x')) sprite.scale.x = random(0.1, 6);
	if (kb.presses('y')) sprite.scale.y = random(0.1, 6);

	if (kb.pressing('a')) sprite.ani.scale.x = 10;
	else sprite.ani.scale.x = 1;
}
			</script>
		</div>

		<div class="break"></div>
		<div id="toc">
			<a id="prevPage" class="navLink">Prev Page</a>
			<nav id="pageNav" class="submenu">
				<a data-page="0" href="sprite.html?page=0">Basic Properties</a>
				<a data-page="1" href="sprite.html?page=1">Physics</a>
				<a data-page="2" href="sprite.html?page=2">Movement</a>
				<a data-page="3" href="sprite.html?page=3">Sprites with Images</a>
				<a data-page="4" href="sprite.html?page=4">Constructor</a>
				<a data-page="5" href="sprite.html?page=5">Collisions</a>
				<a data-page="6" href="sprite.html?page=6">Overlaps</a>
				<a data-page="7" href="sprite.html?page=7">Rotation</a>
				<a data-page="8" href="sprite.html?page=8">Movement Sequencing</a>
				<a data-page="9" href="sprite.html?page=9">Physical Attributes</a>
				<a data-page="10" href="sprite.html?page=10">Chains</a>
				<a data-page="11" href="sprite.html?page=11">Polygons</a>
				<a data-page="12" href="sprite.html?page=12">Custom Draw</a>
				<a data-page="13" href="sprite.html?page=13">Scaling</a>
			</nav>
			<a id="nextPage" class="navLink">Next Page</a>
		</div>
		<div class="break"></div>
		<footer class="text-small">
			Created by Quinton Ashley (@quinton-ashley) Copyright 2022-2023.
		</footer>
	</article>

	<!-- <script src="https://cdn.jsdelivr.net/npm/p5@1/lib/p5.min.js"></script> -->
	<script src="../v3/q5.min.js"></script>
	<script src="../v3/planck.min.js"></script>
	<script src="../v3/p5play.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.8.1/ace.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script src="learn.js"></script>
	<script src="mie.js"></script>
</body>

</html>
