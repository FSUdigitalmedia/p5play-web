<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>p5play : World</title>
	<link rel="icon" href="/assets/p5play_logo.svg">
	<link rel="stylesheet" href="/learn/style.css">
</head>

<body class="dark">
	<article style="display: none;">
		<nav id="topNav">
			<a href="index.html" id="logoLink" class="active">
				<img alt="p5play logo" src="/assets/p5play_logo.svg" class="logo">
				<span>p5play</span>
			</a>
			<hr>
			<a href="canvas.html">Canvas</a>
			<a href="tiles.html">Tiles</a>
			<a href="world.html" class="active">World</a>
			<hr>
			<a id="darkMode" onclick="toggleDarkMode()" tabindex="0" role="button" title="dark mode toggle">
				<div id="darkModeIcon"></div>
			</a>
		</nav>
		<div class="break"></div>

		<div id="page-0" class="page">
			<div class="minis horiz">
				<md id="md0-0">
					<h2 id="world">World</h2>
					<p>Each instance of p5play has its own <code>world</code> object, that can be used to control the
						Box2D physics simulation. Its most important property is <code>gravity</code>, which has x and y
						components.</p>
					<p>Note that the physics simulation is deterministic. That means if you run the same code twice,
						unless you're using random values, you'll get the same result!</p>
				</md>
				<md id="md0-1">
					<h2 id="sleeping">Sleeping</h2>
					<p><code>world.allowSleeping</code> is true by default.</p>
					<p>A sprite starts "sleeping" when it stops moving and doesn't collide with anything new. "Sleeping"
						sprites get ignored during physics simulation, which usually prevents the Box2D physics engine
						solver from having to make unnecessary calculations. While this is good for performance,
						sometimes it can cause problems.</p>
					<p>You can wake up a sleeping sprite by setting <code>sprite.sleeping</code> to false. You can also
						disable sleeping on a per sprite basis by setting <code>sprite.allowSleeping</code> to false.
					</p>
				</md>
			</div>
			<div class="minis horiz">
				<script type="mie/p5" id="sleeping" horiz="">
let ball, floor;

function setup() {
	new Canvas(80, 240);
	world.gravity.y = 10;
	ball = new Sprite(40, 30, 50);
	floor = new Sprite(40, 155, 80, 5, 's');
}

function draw() {
	clear();
	if (frameCount == 100)	floor.rotation = 10;
}
				</script>
				<script type="mie/p5" id="wake-up!" horiz="">
let ball, floor;

function setup() {
	new Canvas(80, 256);
	world.gravity.y = 10;
	ball = new Sprite(40, 30, 50);
	floor = new Sprite(40, 155, 80, 5, 's');
}

function draw() {
	clear();
	if (frameCount == 100)	{
		ball.sleeping = false;
		floor.rotation = 10;
	}
}
				</script>
			</div>
		</div>
		<div id="page-1" class="page">
			<div class="minis horiz">
				<md id="md1-0">
					<h2 id="controlling-time">Controlling Time</h2>
					<p>By default, after each time the p5.js draw function is run, p5play calls three functions in this
						order:</p>
					<ul>
						<li><code>allSprites.draw()</code> : draws all sprites</li>
						<li><code>world.step()</code> : progresses the physics simulation</li>
						<li><code>allSprites.update()</code> : updates animations and mouse events</li>
					</ul>
					<p>But you can also take manual control of these processes by calling them yourself.</p>
				</md>
				<md id="md1-1">
					<h2 id="worldstep">world.step</h2>
					<p>The <code>world.step</code> function calculates the positions and velocities of all sprites after
						progressing the physics simulation by 1/60th of a second by default.</p>
					<p>Set <code>world.autoStep = false</code> to disable automatic stepping, in effect pausing time!
						Then you can call <code>world.step</code> manually when you want to progress the physics
						simulation. Only run it after all sprites have been drawn.</p>
					<p>This mini example shows how a time step can be provided as an input parameter, but note that the
						Box2D physics engine solver is only stable up to a time step of 1/30th of a second. If you want
						to advance the simulation by a larger amount of time, call <code>world.step</code> multiple
						times.</p>
				</md>
			</div>
			<script type="mie/p5" id="world.step">
let ball, box;
		
function setup() {
	new Canvas(500, 192);

	ball = new Sprite(250, 100, 20);
	ball.speed = 10;
	ball.direction = 45;
	ball.bounciness = 1;
	ball.friction = 0;
	ball.strokeWeight = 0;

	box = new Sprite(250, 96, 490, 180, 's');
	box.shape = 'chain';
}

function draw() {
	if (mouse.pressing()) {
		background(0, 0, 0, 30);
		allSprites.draw();
		world.step(1/240);
	} else {
		background(0);
	}
}
			</script>
		</div>
		<div id="page-2" class="page">
			<md id="md2-0">
				<h2 id="performance-testing">Performance Testing</h2>
				<p>The <code>renderStats</code> function displays the number of sprites drawn and FPS approximations.
					For more accurate results, use your web browser's performance testing tools.</p>
				<p>FPS in this context refers to how many frames per second your computer can generate, not including
					the delay between when frames are actually shown on the screen. The higher the FPS, the better your
					game is performing.</p>
				<p>Having less sprites and using a smaller canvas will make your game perform better. For better
					performance, don't use the p5.js <code>clear</code> function or sample the colors of pixels in your
					canvas using <code>canvas.get</code>.</p>
				<p>By default the Box2D physics engine performs 8 velocity and 3 position iterations on each
					<code>world.step</code>. Decreasing these values will make the simulation faster but also less
					accurate.</p>
				<p>I've tested p5play in every web browser and found that Google Chrome performs the best.</p>
			</md>
			<script type="mie/p5" id="renderStats">
function setup() {
	new Canvas(500, 250);

	for (let i = 0; i < 25; i++) {
		let x = 430 - i * 20;
		for (let j = 0; j < 12; j++) {
			new Sprite(x + j * 10, 5 + i * 10, 9, 9);
		}
	}
}

function draw() {
	background(20);
	if (mouse.presses()) new Sprite(mouse.x, mouse.y, 25);
	if (mouse.pressing()) {
		allSprites.at(-1).moveTowards(mouse);
	}
	renderStats();
	allSprites.draw();

	// (timeStep, velocityIterations, positionIterations)
	world.step(1 / 60, 8, 3);
}
			</script>
		</div>

		<div class="break"></div>
		<div id="toc">
			<a id="prevPage" class="navLink">Previous Page</a>
			<div id="pageNav" class="submenu">
				<a data-page="0" href="world.html?page=0">Sleeping</a>
				<a data-page="1" href="world.html?page=1">Controlling Time</a>
				<a data-page="2" href="world.html?page=2">Performance</a>
			</div>
			<a id="nextPage" class="navLink">Next Page</a>
		</div>
		<div class="break"></div>
		<footer id="credits" class="text-small">Created by Quinton Ashley (@quinton-ashley) Copyright 2022-2023</footer>
	</article>

	<script src="/v3/q5.min.js"></script>
<script src="/v3/planck.min.js"></script>
<script src="/v3/p5play.min.js"></script>
<script>
window.mie = { autoLoad: false };

	</script>
	<script src="/learn/mie.js"></script>
<script src="/learn/learn.js"></script>
</body>

</html>
